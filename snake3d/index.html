<!DOCTYPE html>
<html>
    <head>
        <title>Snake 3D</title>
        <style>body { margin: 0; background-image: linear-gradient(#63A9DE, #FFFFFF); }</style>
    </head>
    <body>
        <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.min.js"></script>
        <script>
            // threejs
            const renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            const scene = new THREE.Scene();

            // game speed
            const fps = 60;
            const fpsi = 1000 / fps;
            let now = Date.now();
            let then = now;
            let elapsed = now - then;

            // game state
            const GAMEOVER = 'GAMEOVER';
            const PLAYING = 'PLAYING';
            let state = PLAYING;

            // controls
            const UP = 'UP';
            const DOWN = 'DOWN';
            const LEFT = 'LEFT';
            const RIGHT = 'RIGHT';
            const START = 'START';
            let keydown = false;

            document.onkeydown = function (e) {
                switch (e.keyCode) {
                    case 87: case 38: keydown = UP; break;
                    case 83: case 40: keydown = DOWN; break;
                    case 65: case 37: keydown = LEFT; break;
                    case 68: case 39: keydown = RIGHT; break;
                    case 13: case 32: keydown = START; break;
                    default: keydown = false;
                }
                console.log('keydown', keydown);
            };

            function animate() {
                requestAnimationFrame(animate);

                now = Date.now();
                elapsed = now - then;

                if (elapsed > fpsi) {
                    then = now - (elapsed % fpsi);
                    // _update

                    if (state === PLAYING) {
                        snake.update();
                        apple.update();
                    } else {
                        // GAME OVER
                        for (let n = 0; n < snake.body.length; n++) {
                            snake.body[n].position.y += 0.1;
                        }
                        snake.body[0].material.transparent = true;
                        snake.body[0].material.opacity -= 0.01;

                        if (keydown === START) {
                            for(let n = 0; n < snake.body.length; n++) {
                                scene.remove(snake.body[n]);
                            }
                            snake = new Snake();
                            apple.reposition();
                            state = PLAYING;
                        }
                    }
                }

                // _draw
                renderer.render(scene, camera);
            }

            function rndp() {
                return Math.floor(Math.random() * 19) + 1;
            }

            function collision(object1, object2) {
                object1.geometry.computeBoundingBox();
                object2.geometry.computeBoundingBox();
                object1.updateMatrixWorld();
                object2.updateMatrixWorld();

                var box1 = object1.geometry.boundingBox.clone();
                box1.applyMatrix4(object1.matrixWorld);

                var box2 = object2.geometry.boundingBox.clone();
                box2.applyMatrix4(object2.matrixWorld);

                return box1.intersectsBox(box2);
            }

            const floor = new function() {
                const geometry = new THREE.BoxGeometry(20, 1, 20);
                const material = new THREE.MeshPhongMaterial({ color: 0x555555, opacity: 0.15, transparent: false });
                const obj = new THREE.Mesh(geometry, material);

                obj.position.set(10, 0, 10);
                scene.add(obj);

                return obj;
            };

            const sides = new function() {
                const transparent = new THREE.MeshPhongMaterial({ color: 0x63A9DE, opacity: 0.25, transparent: true });
                const gright = new THREE.BoxGeometry(1, 2, 20);
                const sright = new THREE.Mesh(gright, transparent);
                scene.add(sright);
                sright.position.set(-0.5, 0.5, 10);

                const gleft = new THREE.BoxGeometry(1, 2, 20);
                const sleft = new THREE.Mesh(gleft, transparent);
                scene.add(sleft);
                sleft.position.set(20.5, 0.5, 10);

                const gback = new THREE.BoxGeometry(22, 2, 1);
                const sback = new THREE.Mesh(gback, transparent);
                scene.add(sback);
                sback.position.set(10, 0.5, 20.5);

                const gfront = new THREE.BoxGeometry(22, 2, 1);
                const sfront = new THREE.Mesh(gfront, transparent);
                scene.add(sfront);
                sfront.position.set(10, 0.5, -0.5);
            }

            const camera = new function() {
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(10, 5, 25);
                camera.rotation.set(-0.2, 0, 0);
                return camera;
            }

            const lights = new function() {
                const dire = new THREE.DirectionalLight(0xFFFFFF, 0.4);
                dire.position.set(1, 2, 4);
                scene.add(dire);

                const hemi = new THREE.HemisphereLight(0xFFFFFF, 0x080820, 0.6)
                scene.add(hemi);
            }

            class Snake {
                constructor() {
                    this.speed = 0.25;
                    this.dx = 0;
                    this.dz = 0;
                    this.body = [];
                    this.grow();
                    this.body[0].position.set(10, 1, 18);
                }

                update() {
                    switch(keydown) {
                        case UP:
                            this.dz = -this.speed;
                            this.dx = 0;
                            break;
                        case DOWN:
                            this.dz = this.speed;
                            this.dx = 0;
                            break;
                        case LEFT:
                            this.dx = -this.speed;
                            this.dz = 0;
                            break;
                        case RIGHT:
                            this.dx = this.speed;
                            this.dz = 0;
                            break;
                    }

                    for(let n = this.body.length-1; n > 0; n--) {
                        this.body[n].position.x = this.body[n-1].position.x;
                        this.body[n].position.y = this.body[n-1].position.y;
                        this.body[n].position.z = this.body[n-1].position.z;
                    }

                    this.body[0].position.x += this.dx;
                    this.body[0].position.z += this.dz;

                    if (this.body[0].position.z < 10) {
                        camera.position.z += 2*(this.dz);
                    } else {
                        camera.position.z = 25;
                    }

                    this.isdead();
                }

                grow() {
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshPhongMaterial({color: 0x67DE3E});
                    const body = new THREE.Mesh(geometry, material);

                    body.position.set(10, 5, 30);

                    scene.add(body);
                    this.body.push(body);
                }

                isdead() {
                    // snake self collision
                    for(let n = 10; n < this.body.length; n++) {
                        if (collision(this.body[0], this.body[n])) {
                            state = GAMEOVER;
                        }
                    }

                    // snake bounds collision
                    if (this.body[0].position.x < 0.5 || this.body[0].position.x > 19.5 || this.body[0].position.z < 0.5 || this.body[0].position.z > 19.5) {
                        state = GAMEOVER;
                    }

                    if (state === GAMEOVER) {
                        const material = new THREE.MeshPhongMaterial({color: 0xFFFFFF});

                        for(let n = 0; n < this.body.length; n++) {
                            this.body[n].material = material;
                        }
                    }
                }
            }

            class Apple {
                constructor() {
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshPhongMaterial({color: 0xFF0000});
                    const body = new THREE.Mesh(geometry, material);

                    body.position.set(rndp(), 1, rndp());
                    scene.add(body);

                    this.body = body;
                }

                update() {
                    if (collision(this.body, snake.body[0])) {
                        this.reposition();
                        snake.grow();
                    }
                }

                reposition() {
                    this.body.position.set(rndp(), 1, rndp());
                }
            }

            // init
            let apple = new Apple();
            let snake = new Snake();

            animate();
        </script>
    </body>
</html>
